<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Routing of Airplanes to Two Runways: Monotonicity of Optimal Controls</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2003-10-27">October 27, 2003</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,178.39,212.42,54.78,10.91;1,233.17,210.53,1.41,7.97"><forename type="first">N</forename><surname>Bäuerle</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Inst. für Mathematische Stochastik</orgName>
								<orgName type="institution">Universität Hannover</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,240.33,212.42,105.32,10.91"><forename type="first">O</forename><surname>Engelhardt-Funke</surname></persName>
						</author>
						<author role="corresp">
							<persName coords="1,355.10,212.42,60.16,10.91;1,419.16,210.53,1.88,7.97"><forename type="first">M</forename><surname>Kolonko</surname></persName>
							<email>kolonko@math.tu-clausthal.de</email>
							<affiliation key="aff1">
								<orgName type="department">Institut für Mathematik</orgName>
								<orgName type="institution">Technical University Clausthal</orgName>
								<address>
									<addrLine>Erzstr. 1</addrLine>
									<postCode>D-38678</postCode>
									<settlement>Clausthal-Zellerfeld, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Routing of Airplanes to Two Runways: Monotonicity of Optimal Controls</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2003-10-27">October 27, 2003</date>
						</imprint>
					</monogr>
					<idno type="MD5">8CE41B200E9FA61F9C82708C6B07A818</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2024-05-13T21:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the problem of routing incoming airplanes to two runways of an airport. Due to air turbulence, the necessary separation time between two successive landing operations depends on the types of the airplanes. When viewed as a queueing problem, this means that we have dependent service times. The aim is to minimise waiting times of aircrafts.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="13" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="14" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="15" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="16" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="17" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="18" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="19" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="20" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="21" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="22" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="23" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider here a model where arrivals form a stochastic process and where the decision maker does not know anything about future arrivals. We formulate this as a problem of stochastic dynamic programming and investigate monotonicity of optimal routing strategies with respect e.g. to the workload of the runways.</p><p>We show that an optimal strategy is monotone (i.e. of switching type) only in a restricted case where decisions depend on the state of the runways only and not on the type of the arriving aircraft. Surprisingly, in the more realistic case where this type is also known to the decision maker, monotonicity need not hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In modern air traffic the efficient use of the available runway capacity is of growing importance at least at major airports. Airplanes are often queued when waiting for a free runway to land on. While queueing and during the landing operations, the airplanes have to keep a large enough distance between each other to avoid air turbulence from aircrafts flying ahead. These separation times depend on the weight (more generally: types) of the airplanes involved. Typically, the necessary separation between a light aircraft trailing a heavy one will be larger than between the same types if the light one is flying in front. Hence, one can expect to increase the throughput of the runways by an efficient routing of arriving airplanes to runways.</p><p>The general problem is quite involved as a lot of side constraints and airport specific rules have to be considered. We restrict ourselves to a particular scenario, which may be viewed as a step towards more realistic models that we cannot analyse completely at present. First, we assume that the arrival times of the aircrafts form a stochastic renewal process. This is in accordance with e.g. <ref type="bibr" coords="2,205.72,314.28,11.52,9.79" target="#b3">[4]</ref> and <ref type="bibr" coords="2,244.44,314.28,10.91,9.79" target="#b7">[8]</ref>. There it is assumed that the scheduled arrival times are highly disturbed (e.g. by varying flight conditions, delays on connecting flights or technical problems) such that in practise the arrival times may well be approximated by a Poisson process.</p><p>We further assume that the routing decision has to be made at the arrival instance of the airplane at the airport (or at a certain threshold). The decision maker may use information on the state of the runways and the type of the presently arriving aircraft but does not know anything about future arrivals. Once an aircraft has been assigned to a runway it must stay in the queue of that runway. The queues are served on a first come first served basis. The aim is to find a rule that assigns an incoming aircraft to a runway given the state of the system and the type of arriving aircraft such that the long term expected waiting times are minimised.</p><p>We formulate a stochastic dynamic programming model for this problem with the total expected discounted waiting time of the aircrafts as target function. We investigate monotonicity properties of optimal routing strategies (policies) in this model. Monotonicity here means e.g. that when the observed workload u on runway I increases while everything else is kept fixed then an assignment of an arriving plane to runway I will only be made for u up to a certain level l. For u &gt; l the aircraft will then be assign to runway II. Such policies are also called 'switching policies' as they are completely determined by switching levels l. This will be made more precise by defining a partial order on the state space of the dynamic programming model and by proving monotonicity of optimal routing policies with respect to this ordering.</p><p>Here are our main findings: optimal policies are monotone only if we restrict ourselves to decisions that depend solely on the state of the runway and not on the type of the presently arriving aircraft. This result also yields conditions under which a simple Join-the-Least-Load strategy (JLL) is optimal. We give a rough bound on the error that is made when using JLL in the general case where it is not optimal. Surprisingly, monotonicity with respect to workloads need not hold in the more realistic model where decisions may depend on the state of the runways as well as on the type of the arriving airplane. We show by a counter example based on realistic data that in this case it may be optimal to route to runway II for a small workload u on runway I and to route to runway I for a larger workload u . This somewhat unexpected result may be explained from the fact that in the first restricted case we use a cost function (see definition <ref type="bibr" coords="2,72.00,722.15,22.23,9.79">(3.5)</ref>) where the dependency of waiting times from the next arriving aircraft is 'averaged out' whereas in the second case we use as cost function the actual waiting time (see (6.2)) leading to a more sensitive criterion.</p><p>The proof of the main monotonicity result is based on the approach in <ref type="bibr" coords="2,421.70,767.78,10.92,9.79" target="#b0">[1]</ref>. Nevertheless, our model does not fit into the framework of <ref type="bibr" coords="2,278.23,781.33,10.92,9.79" target="#b0">[1]</ref>. We had to change the conditions at a minute but decisive point and to prove that the main assertions of <ref type="bibr" coords="3,368.78,112.39,11.52,9.79" target="#b0">[1]</ref> still hold under the modified assumptions.</p><p>Optimal routing of airplanes has been treated e.g. in <ref type="bibr" coords="3,342.98,144.17,11.52,9.79" target="#b2">[3]</ref> where also a survey over different approaches is given. Deterministic models as in <ref type="bibr" coords="3,315.52,157.72,11.52,9.79" target="#b2">[3]</ref> often assume that a set of airplanes to be scheduled and routed is given. This allows to take into account more than one arrival and optimal schedules for a single set of aircrafts are obtained by mixed linear optimisation. The stochastic queueing models in <ref type="bibr" coords="3,242.43,198.37,11.52,9.79" target="#b3">[4]</ref> and <ref type="bibr" coords="3,279.75,198.37,11.52,9.79" target="#b7">[8]</ref> do not take into account the dependency of the separation times from the two types involved. In <ref type="bibr" coords="3,307.30,211.91,11.52,9.79" target="#b1">[2]</ref> M/SM/1 queueing models are used to deal with this dependency. In a somewhat complementary way to the present paper, strategies that use only the type of the arriving aircrafts are considered. There, it is also shown that neglecting the dependencies may lead to a strongly biased estimation of waiting times under heavy traffic. The general literature on the routing of parallel queues (see e.g. <ref type="bibr" coords="3,382.88,266.11,16.98,9.79" target="#b12">[13]</ref>) seems to be restricted to the case of independent service times only. Queues with dependent service times are treated e.g. in <ref type="bibr" coords="3,84.73,293.21,16.01,9.79" target="#b9">[10]</ref>, but without any reference to routing.</p><p>The paper is organised as follows. In Section 2, we collect a few results from stochastic dynamic programming, in particular about the optimality equations and value iteration. In Section 3 we use the dynamic programming framework to formalise the restricted model, where decisions depend on the state of the runways alone. Here, we also define the load of a runway and the ordering of the state space and give the main monotonicity results. We start with this restricted model as it takes most of the paper to prove these results. The rather technical proof is given in Section 7. A number of Corollaries about Join-the-Least-Load policies are collected in Section 5. The model of Section 3 is then enlarged in Section 6 to include the type of arriving airplane and a counter-example shows that the monotonicity property does no longer hold. In the Conclusion we address the potential benefit of our results for the practical solution of the problem and topics of our future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Dynamic Programming Model</head><p>We shall first collect a few definitions and results from Markovian dynamic programming (see e.g. <ref type="bibr" coords="3,94.71,528.26,10.91,9.79" target="#b4">[5]</ref>, <ref type="bibr" coords="3,113.52,528.26,16.97,9.79" target="#b10">[11]</ref> or <ref type="bibr" coords="3,148.51,528.26,16.97,9.79" target="#b11">[12]</ref> for a general discussion of dynamic programming). Here, we present only a simple type of dynamic programming model which is sufficient to cover the aircraft routing problem formulated in the next Section.</p><p>The model describes a system that is observed at discrete points of time (stages) n = 1, 2, . . . . At each stage the system is observed to be in a state s ∈ S. Then an action a ∈ A is taken and the system moves to a new state s = g(s, a, z) ∈ S to be observed at the next stage. Here, z ∈ Z is an external event (disturbance) and g : S × A × Z → S is the state transition function. The state-action pair (s, a) causes costs c(s, a), where c : S × A → IR + is the cost function. Let (Z n ) n≥1 be an i.i.d. sequence of external random variables with values in Z and with a known distribution.</p><p>We shall leave aside questions of measurability and assume in particular that the action space A is finite.</p><p>If we observe the system for a finite number N of stages (finite horizon case), actions are chosen according to a policy δ = (f N , . . . , f 1 ), where f n : S → A is the decision rule for the N −n+1−th stage. The reverse numbering of the decision rules simplifies the description of the induction below. Given a starting state X 1 = s from S and a policy δ, the sequence of states X 2 , . . . , X N is then defined recursively by</p><formula xml:id="formula_0" coords="3,173.96,781.07,249.62,11.87">X n+1 := g(X n , f N −n+1 (X n ), Z n ), 1 ≤ n ≤ N − 1.</formula><p>(2.1) The total expected discounted costs for policy δ = (f N , . . . , f 1 ) and starting state s ∈ S are given by</p><formula xml:id="formula_1" coords="4,72.00,112.39,122.90,11.19">With A n := f N −n+1 (X n ),</formula><formula xml:id="formula_2" coords="4,191.40,184.25,334.15,34.95">V N,δ (s) : = E N k=1 β k−1 c(X k , A k ) | X 1 = s (2.3)</formula><p>where β ∈ (0, 1] is a given discount factor. As our cost function is non-negative and the action space is finite, it is well known (see e.g. <ref type="bibr" coords="4,259.67,240.00,16.70,9.79" target="#b11">[12]</ref>) that an optimal policy exists, i.e. a policy δ * , with</p><formula xml:id="formula_3" coords="4,178.01,263.83,241.52,17.53">V N (s) := V N,δ * (s) = min δ V N,δ (s) for all s ∈ S.</formula><p>(2.4)</p><p>In fact the min may be taken over a much larger class of policies than defined above. For (measurable) functions w : S → IR + we define the one-stage cost operator L by</p><formula xml:id="formula_4" coords="4,182.75,329.52,342.79,28.35">L a w(s) := c(s, a) + β E [w(X 2 ) | X 1 = s, A 1 = a] = c(s, a) + β E w(g(s, a, Z 1 )). (2.5)</formula><p>Problem (2.4) can be solved recursively with the help of the so-called optimality equation for dynamic programs which in the finite horizon case reads</p><formula xml:id="formula_5" coords="4,175.71,408.33,349.84,17.44">V n (s) = min a∈A L a V n−1 (s) for all s ∈ S, 1 ≤ n ≤ N. (<label>2.6)</label></formula><p>We assume throughout that V 0 ≡ 0. A policy δ * = (f * N , . . . , f * 1 ) is optimal iff f * n (s) selects a minimising action in (2.6) for s ∈ S, 1 ≤ n ≤ N (see e.g. <ref type="bibr" coords="4,343.80,451.55,16.01,9.79" target="#b11">[12]</ref>, Cor. 6.2).</p><p>In the infinite horizon case we only consider stationary policies δ = (f n ) n≥1 with f n ≡ f, n ≥ 1 and we write δ = f for short. With A k = f (X k ), k ≥ 1 we define the total expected discounted costs by</p><formula xml:id="formula_6" coords="4,72.00,506.35,453.55,83.05">V δ (s) : = E ∞ k=1 β k−1 c(X k , A k ) | X 1 = s . (2.7) Again, δ * is called optimal if V (s) := V δ * (s) = min δ V δ (s), s ∈ S. (2.8)</formula><p>It is shown in <ref type="bibr" coords="4,143.21,601.13,16.98,9.79" target="#b11">[12]</ref> that there exists an optimal stationary policy which can be obtained from the infinite horizon optimality equation</p><formula xml:id="formula_7" coords="4,227.29,638.50,142.96,17.44">V (s) = min a∈A L a V (s), s ∈ S.</formula><p>(2.9)</p><p>f * forms an optimal stationary policy iff f * (•) is a minimiser of (2.9). Moreover, value iteration holds, i.e. lim</p><formula xml:id="formula_8" coords="4,227.52,694.60,142.51,17.44">N →∞ V N (s) = V (s), s ∈ S.</formula><p>(2.10)</p><p>Below, we use (2.6) to derive properties for the finite horizon case with arbitrary horizon N using inductive arguments. These properties then carry over to the infinite horizon case using (2.10).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Optimal Aircraft Routing as Dynamic Programming Problem</head><p>We shall now specify the elements of the dynamic programming model such that the problem of optimal aircraft routing can be dealt with.</p><p>We start with the external events Z n . Let S n , n ≥ 1, denote the arrival times of airplanes at the airport. We assume that the interarrival times T n := S n − S n−1 ≥ 0 for n ≥ 1, with S 0 := 0 are i.i.d. , i.e. the arrivals form a renewal process with some distribution F. Let J be the finite set of possible types of airplanes and denote by J n the type of the n−th arriving plane. We assume that the J n , n ≥ 1, are i.i.d. and independent of the arrival process with</p><formula xml:id="formula_9" coords="5,72.00,249.35,453.55,48.00">p i := P(J n = i), i ∈ J. Then Z n := (J n , T n+1 ), n ≥ 1 (3.1)</formula><p>taking on values in Z := J × IR + , describes the type of the n-th arriving aircraft and the following interarrival time. (Z n ) n≥1 is an i.i.d. sequence, it is the external source of randomness in our model.</p><p>We assume that if an aircraft of type j is to land immediately behind an aircraft of type i on the same runway, then there must be a safety distance given as separation time b(i, j) ≥ 0, i, j ∈ J. This means that the beginning of the two landing operations (touch-downs) must be b(i, j) time units apart.</p><p>In our model, routing decisions have to be made at the arrival instances S n of airplanes which define our decision epochs. Let A := {I, II} where action a = I (a = II) means to route the present airplane to runway I (II). Once an airplane has been routed to a queue it has to wait there for its service. The queues work on a first-come-first-served basis.</p><p>To define the 'state' of our system we first consider a single runway, say runway I. Of course, things are completely analogous on runway II.</p><p>Let ζ I n denote the type of airplane that is at the tail of the queue of runway I immediately before the n−th arrival takes place. If the queue I is empty at that time then ζ I n is the type of the last airplane that landed on I. With ζ I 1 := i 0 (an arbitrary type), the formal definition of ζ I n is</p><formula xml:id="formula_10" coords="5,157.20,549.73,368.34,25.74">ζ I n+1 := J n if Z n = (J n , T n+1 ) and A n = I ζ I n if A n = II , n ≥ 1. (3.2)</formula><p>For n ≥ 2, ζ I n is the type of plane that the n−th plane will see as its predecessor if it is routed to runway I. Note that the index n counts arrivals to the airport, not to the particular runway.</p><p>Let U I n denote the workload on runway I immediately before the arrival of the n−th airplane. U I n is the time that the last plane at the tail of the queue has to wait until the beginning of its landing operation. If the queue is empty at that time then U I n &lt; 0 denotes the time that has passed since the last plane began its landing on runway I . Let b * := max i,j∈J b(i, j). With U I 1 := −b * the formal definition of the workload is given by <ref type="figure" coords="5,345.21,768.20,42.44,9.79;5,388.44,765.77,3.67,7.97">Here, b(ζ I</ref> n , J n ) can be regarded as the service time of this plane. The definition of ζ I 1 and U I 1 guarantees that the first aircrafts on each runway have waiting time 0. In Fig. <ref type="figure" coords="6,250.43,112.39,4.65,9.79">3</ref>.1 the load on runway a is shown at the arrival instance of the n−th aircraft of type j 4 when two aircrafts of types j 2 , j 3 are already waiting. The black triangles indicate the time at which the landing operation of the aircraft begins. Type j 1 has already landed, but j 2 still has to wait.</p><formula xml:id="formula_11" coords="5,72.00,697.85,453.55,80.14">U I n+1 := [U I n + b(ζ I n , J n )] + − T n+1 if Z n = (J n , T n+1 ) and A n = I U I n − T n+1 if Z n = (J n , T n+1 ) and A n = II , n ≥ 1. (3.3) Note that [U I n + b(ζ I n , J n )] + is the waiting time of the n−th plane if it is routed to I.</formula><p>on the ground waiting in the air</p><formula xml:id="formula_12" coords="6,108.68,176.94,284.03,135.33">j 1 j 2 j 3 j 4 b(j 1 , j 2 ) S n U a n b(j 2 , j 3 ) b(j 3 , j 4 ) Figure 3.1:</formula><p>The load on runway a when aircrafts of types j 1 , . . . , j 4 are present</p><p>The state of runway I at the arrival instance of the n−th plane is the pair (ζ I n , U I n ) taking on values in J × IR. Note that it is possible to bound the workload from below, as we need not keep track of negative loads that are larger than b * = max i,j∈J b(i, j).</p><p>The state of the second runway is defined in a completely analogous way and the state of the system at the n−th arrival instance is then defined as</p><formula xml:id="formula_13" coords="6,239.38,405.52,118.78,15.18">X n := (ζ I n , U I n , ζ II n , U II n )</formula><p>taking on values in the state space S := J × IR × J × IR.</p><p>Note that in this model the presently arriving type J n is not part of the state but part of the external event Z n = (J n , T n+1 ) that drives the system. This follows from our particular restriction that the type J n is not known to the decision maker. Below, in the case where J n is known we shall use (J n+1 , T n+1 ) as the external event driving the system (see Section 6). ¿From (3.2) and (3.3) we now see how the state transition function g :</p><formula xml:id="formula_14" coords="6,72.00,507.22,453.55,69.20">S × A × Z → S must be defined. For s = (i, u, j, v) ∈ S, a ∈ A and z = (l, t) ∈ Z let g((i, u, j, v), a, (l, t)) := ⎧ ⎨ ⎩ l, [u + b(i, l)] + − t, j, v − t if a = I i, u − t, l, [v + b(j, l)] + − t if a = II. (3.4)</formula><p>As one-stage cost function c :</p><formula xml:id="formula_15" coords="6,175.39,590.62,350.16,49.71">S × A → IR + we define for s = (i, u, j, v) ∈ S c(s, a) := j ∈J p j • [u + b(i, j )] + if a = I j ∈J p j • [v + b(j, j )] + if a = II. (3.5)</formula><p>If we denote by</p><formula xml:id="formula_16" coords="6,72.00,660.38,311.20,55.46">W n := [U An n + b(ζ An n , J n )] + the waiting time of the n−th airplane, then we have c(s, a) = E [W n | X n = s, A n = a].</formula><p>Note that c((i, u, j, v), a) depends only on the state of runway a, e.g. on (i, u) for a = I. The total discounted expected costs now read</p><formula xml:id="formula_17" coords="6,77.45,760.68,448.10,34.96">V N,δ (s) = E N k=1 β k−1 c(X k , A k ) | X 1 = s = E N k=1 β k−1 [U An n +b(ζ An n , J n )] + | X 1 = s (3.6)</formula><p>and similar for the infinite horizon. Starting in an empty system means to have X 1 = s 0 := (i 0 , −b * , i 0 , −b * ). As we have only two actions, the optimality equations (2.6) and (2.9) have a particularly simple structure:</p><formula xml:id="formula_18" coords="7,99.06,162.71,426.48,11.19">V n (s) = min{L I V n−1 (s), L II V n−1 (s)} and V (s) = min{L I V (s), L II V (s)}. (3.7)</formula><p>Also, (2.5) becomes</p><formula xml:id="formula_19" coords="7,110.67,208.82,369.68,46.02">L I w(s) = c(s, I) + βE w(g(s, I, Z 1 )) = l∈J p l [u + b(i, l)] + + β ∞ 0 w((l, [u + b(i, l)] + − t, j, v − t))F (dt)</formula><p>where F is the distribution of the interarrival times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Monotonicity Properties of Optimal Policies</head><p>In this Section we show that optimal routing policies are monotone with respect to a particular (partial) ordering of the state space. As usual, 'increasing' and 'decreasing' are used in the non-strict sense.</p><p>Let us first define a partial ordering on the set of types J. For i, j ∈ J define</p><formula xml:id="formula_20" coords="7,186.50,401.19,339.05,11.87">i ≺ J j : ⇐⇒ b(i, k) ≤ b(j, k) for all k ∈ J. (<label>4.1)</label></formula><p>In the aircraft setting, i ≺ J j could indicate that j is a heavier plane that requires more separation than i. We do not make any assumptions on the ordering of the separation times, hence, in the extreme case, it may happen, that i ≺ J j only holds for i = j. Now let s = (i, u, j, v), s = ( ī, ū, j, v) ∈ S, then we define</p><formula xml:id="formula_21" coords="7,190.32,491.23,335.22,13.68">s ≺ s : ⇐⇒ i ≺ J ī, u ≤ ū, j J j, v ≥ v (4.2)</formula><p>If s ≺ s holds, then in state s the load on runway I is at least as high as in state s and at its tail there is an aircraft that requires at least as much separation time as in s. For runway II the opposite relation holds. Hence, the balance of the two queues is more favourable for I in state s than it is in s.</p><formula xml:id="formula_22" coords="7,72.00,575.23,453.56,76.82">A function f : S → M, where (M, ≤) is a (partially) ordered set, is called s-increasing if s ≺ s implies f (s) ≤ f (s). For f n : S → A, we define the order ≤ on A by I ≤ II. Note that f : S → IR is s-increasing if and only if u, i → f (i, u, j, v) are increasing for fixed j, v and v, j → f (i, u, j, v) are decreasing for fixed i, u. (4.3)</formula><p>Here, monotonicity in i and j is defined w.r.t. the ordering (4.1) whereas monotonicity in u and v w.r.t. the usual ordering on IR.</p><p>The following Theorem is the main result of this Section. It shows that optimal policies are monotone w.r.t. to the ordering (4.2) of the state space. Some implications are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Theorem a) (finite horizon case)</head><p>For any horizon N there is an optimal policy δ = (f N , . . . , f 1 ) such that s → f n (s) is s-increasing for n = 1, . . . , N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>b) (infinite horizon case)</head><p>There is an optimal stationary policy δ = f such that s → f (s) is s-increasing.</p><p>In fact any optimal policy is monotone in this sense if we agree to choose the smaller action I in cases where both actions are minimising the optimality equations. Theorem 4.1 states that if it is optimal to route the next airplane to runway II in a state s = (i, u, j, v), then we should do the same in all states s with s ≺ s.</p><p>Note that f n is s-increasing if and only if there exists a 'level' function</p><formula xml:id="formula_23" coords="8,72.00,210.70,453.55,82.63">l n : J 2 × IR → IR with i → l n (i, j, v) decreasing and j, v → l n (i, j, v) increasing such that for s = (i, u, j, v) ∈ S f n (s) = I if u &lt; l n (i, j, v) II if u &gt; l n (i, j, v) (4.4) (for the 'only-if'-part put l n (i, j, v) := inf{u | f n (i, u, j, v) = II}).</formula><p>In this sense, an s−increasing policy is a 'switching policy'.</p><p>The proof of Theorem 4.1 is quite lengthy and only its main steps are given below, the remainder is split into several technical Lemmata given in Section 7 below.</p><p>Proof : (of Theorem 4.1) a) For the finite horizon case, define</p><formula xml:id="formula_24" coords="8,199.25,395.28,199.04,11.87">Δ n (s) := L I V n (s) − L II V n (s), n ≥ 1.</formula><p>From the optimality equation (2.6) it follows that (f N , f N −1 , . . . , f 1 ) with</p><formula xml:id="formula_25" coords="8,175.18,437.56,247.19,25.36">f n (s) := I, if Δ n−1 (s) ≤ 0 II, if Δ n−1 (s) &gt; 0 , 1 ≤ n ≤ N,</formula><p>forms an optimal policy for the N -stage problem. In Lemma 7.3 below it is shown that s → Δ n (s) is s-increasing, hence it follows that s → f n (s) is s-increasing as well.</p><p>b) For the infinite horizon, we conclude from the value iteration (2.10) that if s → Δ n (s) is s-increasing for all n ≥ 1 then</p><formula xml:id="formula_26" coords="8,190.93,538.02,215.67,16.72">Δ(s) := L I V (s) − L II V (s) = lim n→∞ Δ n (s)</formula><p>is an s-increasing function, too. Here, lim n→∞</p><formula xml:id="formula_27" coords="8,303.28,563.27,222.29,11.19">L I V n = L I V is shown in [12], 4.4.1. Now b)</formula><p>follows as in a).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">When is Join-the-Least-Load (JLL) optimal?</head><p>A natural simple policy would be to route the next arriving airplane to the runway with the least load, i.e. for s = (i, u, j, v) to decide according to δ = ( fN , . . . , f1 ) where fn (s) := f (s) :=</p><formula xml:id="formula_28" coords="8,310.42,694.55,215.13,24.01">I if u ≤ v II if u &gt; v . (<label>5.1)</label></formula><p>However, due to the structure of the service times b(i, j) one cannot expect this policy to be optimal in general. We now examine some special cases where JLL is optimal. First, we state a simple consequence of the symmetry of the two runways.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Lemma</head><p>Let s := (i, u, j, v) ∈ S and s := (j, v, i, u), then we have</p><formula xml:id="formula_29" coords="9,174.01,134.43,276.79,11.81">V n (s) = V n (s) for all n ≥ 1 and V (s) = V (s).</formula><p>For finite and infinite horizon it holds that action I is optimal in state s iff action II is optimal in state s</p><p>Proof : From (3.5) and (3.4) we see that c(s, I) = c(s, II). Starting with V 0 ≡ 0 we obtain inductively</p><formula xml:id="formula_30" coords="9,72.00,244.28,417.27,72.25">L I V n−1 (s) = c(s, I) + βE V n−1 (g(s, I, Z 1 )) = c(s, II) + βE V n−1 (g(s, II, Z 1 )) = L II V n−1 (s) hence V n (s) = max{L I V n−1 (s), L II V n−1 (s)} = max{L II V n−1 (s), L I V n−1 (s)} = V n (s)</formula><p>and</p><formula xml:id="formula_31" coords="9,163.27,340.92,271.01,11.87">L I V n−1 (s) ≤ L II V n−1 (s) ⇐⇒ L II V n−1 (s) ≤ L I V n−1 (s).</formula><p>The corresponding results for the infinite horizon follow from (2.10) and (2.9).</p><p>The following Theorem is a direct consequence of Theorem 4.1 and the symmetry of the runways. It shows in particular that it is optimal to use JLL in states where both runways have identical types waiting at their tails. Note that we use the ordering defined by (4.1) on the set J of types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Theorem a)</head><p>Let s = (i, u, j, v) ∈ S. If u ≤ v and i ≺ J j then it is optimal to use action I, and if u ≥ v and i J j then it is optimal to use action II.</p><p>b) For any state s = (i, u, i, v) ∈ S it is optimal to choose a = I if and only if u ≤ v.</p><p>c) For any state s = (i, u, j, u) ∈ S it is optimal to choose a = I if i ≺ J j and a = II if j ≺ J i.</p><p>These statements hold for the finite as well as for the infinite horizon problem.</p><p>Proof : a) Let s := (j, v, i, u), then using Lemma 5.1 we have</p><formula xml:id="formula_32" coords="9,145.98,610.97,370.60,11.87">Δ n (s) = L I V n (s) − L II V n (s) = L II V n (s) − L I V n (s) = −Δ n (s). (5.</formula><p>2)</p><p>The assumptions u ≤ v, i ≺ J j imply s ≺ s and from Lemma 7.3 we obtain Δ n (s) ≤ Δ n (s) = −Δ n (s). Hence Δ n (s) ≤ 0, i.e. action I is optimal. An analogous argument holds for the infinite horizon case. The assertion concerning action II follows from symmetry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>b) and c) follow from a).</head><p>A degenerate special case is obtained if the separation times do not depend on the leading aircraft, i.e. b(i, j) ≡ d(j) for all i, j ∈ J. In this situation it is unnecessary to keep track of the type of the last airplanes on the runways and the state space of the problem could be reduced to the load (u, v) on the two runways. Theorem 4.1 then implies that the JLL policy δ is optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Corollary</head><p>If b(i, j) ≡ d(j) for all i, j ∈ J, then it is always optimal to route the next airplane to the runway with least load (for finite as well as infinite horizon).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof :</head><p>We have for all i, j</p><formula xml:id="formula_33" coords="10,170.72,164.85,256.10,35.90">∈ J i ≺ J j ⇐⇒ ∀ k ∈ J b(i, k) = d(k) ≤ b(j, k) = d(k)</formula><p>hence all types in J are equal with respect to the ordering given by (4.1). But then the assertion follows from Theorem 5.2 b). be the span of separation times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Theorem</head><p>Let δ be the JLL policy as defined in (5.1). For all s ∈ S it holds that</p><formula xml:id="formula_34" coords="10,226.77,392.14,298.78,34.96">0 ≤ V N δ (s) − V N (s) ≤ B N −1 k=1 β k k (5.3)</formula><p>and for the infinite horizon and β &lt; 1</p><formula xml:id="formula_35" coords="10,231.25,458.91,162.32,25.10">0 ≤ Vδ(s) − V (s) ≤ B β (1 − β) 2 .</formula><p>(5.4)</p><p>For the proof we have to consider auxiliary systems with the only difference being modified separation times b(i, j). Note that in these systems we not only have a different cost function ĉ(s, a) (related to the separation times as given by (3.5)), but also a different transition function ĝ and a different state process Xn = ( ζI n , Û I n , ζII n , Û II n ). The value functions for the modified system are denoted by Vn (s) etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Lemma a)</head><p>Let b(i, j) ≤ b(i, j) for all i, j ∈ J, then for any s ∈ S we have </p><formula xml:id="formula_36" coords="10,200.68,649.95,249.11,13.95">VN (s) ≤ V N (s), N ≥ 1 and V (s) ≤ V (s).</formula><formula xml:id="formula_37" coords="10,194.20,700.92,256.78,63.22">≤ VN δ (s) − V N δ (s) ≤ B N −1 k=1 β k k, N ≥ 1 and 0 ≤ Vδ(s) − Vδ(s) ≤ B β (1 − β) 2 .</formula><p>Proof : a) The proof is done by induction on N . For N = 0 the statement is trivially true. Now suppose it holds for n ∈ IN, i.e. Vn (s) ≤ V n (s) is valid for all s ∈ S. We know that</p><formula xml:id="formula_38" coords="11,212.72,149.08,172.09,11.19">V n+1 (s) = min{L I V n (s), L II V n (s)}</formula><p>and similar for V . From our assumptions and the induction hypothesis we obtain (note that s → V n (s) is obviously increaing in u and v which can formally also been shown by induction)</p><formula xml:id="formula_39" coords="11,174.28,206.15,248.99,47.02">L I Vn (s) = ĉ(s, I) + βE[ Vn (ĝ(s, I, Z 1 ))] ≤ c(s, I) + βE[ Vn (g(s, I, Z 1 ))] ≤ c(s, I) + βE[V n (g(s, I, Z 1 ))] = L I V n (s)</formula><p>and similarly L II Vn (s) ≤ L II V n (s) which implies the result.</p><p>b) Let A k and Âk be the k−th action under the JLL policy in the original model and in the hat-model. Note that we may have A k = Âk and that</p><formula xml:id="formula_40" coords="11,174.23,316.25,249.09,18.67">U A k k = min{U I k , U II k } and Û Âk k = min{ Û I k , Û II k }.</formula><p>We first prove</p><formula xml:id="formula_41" coords="11,118.89,365.20,406.66,15.24">min{U I k , U II k } ≤ min{ Û I k , Û II k } and max{U I k , U II k } ≤ max{ Û I k , Û II k }. (<label>5.5)</label></formula><p>Again for k = 1 nothing has to be shown. Now assume that (5.5) holds for some k, we have</p><formula xml:id="formula_42" coords="11,114.01,411.47,411.54,80.42">min{U I k+1 , U II k+1 } (5.6) = min [min{U I k , U II k } + b(ζ A k k , J k )] + − T k+1 , max{U I k , U II k } − T k+1 ≤ min [min{ Û I k , Û II k } + b * ] + − T k+1 , max{ Û I k , Û II k } − T k+1 = min{ Û I k+1 , Û II k+1 }.</formula><p>We see that (5.6) also holds if the outer min is replaced by max, hence, (5.5) is proven. From this we obtain for all k</p><formula xml:id="formula_43" coords="11,170.86,534.71,354.68,57.75">c(X k , A k ) = j∈J p j [min{U I k , U II k } + b(ζ A k k , J k )] + ≤ j∈J p j [min{ Û I k , Û II k } + b * ] + = ĉ( Xk , Âk )<label>(5.7)</label></formula><p>which in turn implies V N, δ (s) ≤ VN, δ (s).</p><p>(5.8)</p><p>To complete the proof of b) we have to show that</p><formula xml:id="formula_44" coords="11,223.02,658.02,153.17,34.96">VN, δ (s) ≤ V N, δ (s) + B N −1 k=1 β k k.</formula><p>(5.9)</p><p>Similar to (5.6) we first show that</p><formula xml:id="formula_45" coords="11,72.00,724.01,453.55,69.01">min{ Û I k , Û II k } ≤ min{U I k , U II k } + (k − 1) B and max{ Û I k , Û II k } ≤ max{U I k , U II k } + (k − 1) B (5.10) which as in (5.7) implies ĉ( Xk , Âk ) ≤ c(X k , A k ) + (k − 1) B (5.11)</formula><p>and hence (5.9) follows. To prove (5.10) we first observe that for k = 1 nothing has to be shown. Now assume (5.10) holds for some k, then</p><formula xml:id="formula_46" coords="12,76.94,147.48,435.89,174.52">min{ Û I k+1 , Û II k+1 } = min [min{ Û I k , Û II k } + b * ] + − T k+1 , max{ Û I k , Û II k } − T k+1 ≤ min [min{U I k , U II k } + (k − 1) B + b * ] + − T k+1 , max{U I k , U II k } + (k − 1) B − T k+1 = min [min{U I k , U II k } + b(ζ A k k , J k ) + (k − 1) B + b * − b(ζ A k k , J k )] + − T k+1 , max{U I k , U II k } + (k − 1) B − T k+1 ≤ min [min{U I k , U II k } + b(ζ A k k , J k ) + k B] + − T k+1 , max{U I k , U II k } + k B − T k+1 ≤ min [min{U I k , U II k } + b(ζ A k k , J k )] + − T k+1 , max{U I k , U II k } − T k+1 + k B = min{U I k+1 , U II k+1 } + k B.</formula><p>Again the same inequalities hold when the outer min is replaced by max. Hence, (5.10) holds and the proof of the Lemma is complete for finite horizons. The infinite horizon case again follows from (2.10).</p><p>For the proof of Theorem 5.4 we consider first an auxiliary system with b(i, j) := b * = min i,j∈J b(i, j) whose value function will be denoted by * V N (s). Similarly, the system with b(i, j) ≡ b * has value function * V N (s). From Corollary 5.3 we know that JLL is optimal in these systems, hence, from Lemma 5.5 a)and b) we see</p><formula xml:id="formula_47" coords="12,171.79,461.54,255.37,15.39">* V N δ (s) = * V N (s) ≤ V N (s) ≤ V N δ (s) ≤ * V N δ (s).</formula><p>(5.12)</p><p>Now we apply Lemma 5.5 b) to the two value functions * V N δ and * V N δ with fixed separation times. We obtain</p><formula xml:id="formula_48" coords="12,219.61,511.64,305.94,34.96">* V N δ (s) − * V N δ (s) ≤ B N −1 k=1 kβ k (5.13)</formula><p>which together with (5.12) implies the assertion of Theorem 5.4 for the finite horizon, the infinite horizon case again follows fom (2.10).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">The Case of Complete Information : A Counter Example</head><p>In this Section, we assume that the controller knows the type of the airplane that has to be routed in addition to the state of the runways. In this case, the control problem is much more complicated. A simple switching policy as in Section 4 need not be optimal any longer as we shall show by a counter example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The Model</head><p>To model the new situation, the type of the newly arrived airplane is now included into the state space, i.e. we put</p><formula xml:id="formula_49" coords="12,145.42,771.58,309.82,15.17">Xn := (J n , ζ I n , U I n , ζ II n , U II n ) and S := J × (J × IR) × (J × IR)</formula><p>where a state s ∈ S is denoted by s = (k, i, u, j, v). k gives the type of the newly arrived airplane and i, u, j, v are as before. As in Section 3 we have an external event z = (l, t), but now l is the type of the airplane to arrive after the next interarrival time t, i.e. Z n = (J n+1 , T n+1 ). Using the notation of Section 3 we may write the transition function g : S × A × Z → S for s = (k, i, u, j, v) and z = (l, t) as g(s, a, z) := </p><formula xml:id="formula_50" coords="13,210.42,179.87,235.60,43.09">⎧ ⎨ ⎩ l, k, [u + b(i, k)] + − t, j, v − t if a = I l, i, u − t, k, [v + b(j, k)] + − t if a = II.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">A Counter Example</head><p>The following example shows that a monotonicity result similar to that of Theorem 4.1 cannot hold in the present scenario. More precisely, if routing the airplane to runway I in state s = (k, i, u, j, v) is optimal then it need not be optimal to route the airplane to runway I in a state s = (k, i, ū, j, v), where ū &lt; u. Hence, with respect to any (partial) ordering ≺ of S which has s ≺ s for the above states, monotonicity as in Theorem 4.1 needs not hold. As a consequence, Theorem 5.2, Corollary 5.3 and Theorem 5.4 are no longer valid, though Lemmata 5.1 and 5.5 hold.</p><p>The counter example has a very small ū &lt; 0, i.e. the last touch-down on runway I was a long time ago. Then, if the current airplane needs only a small safety distance to the preceding one, it might be better to save runway I for a future airplane which needs a larger separation time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example:</head><p>We assume that there are three types of aircrafts, J = {1, 2, 3} and that the matrix of separation times is as given in <ref type="bibr" coords="13,166.73,727.18,10.92,9.79" target="#b3">[4]</ref>: Let F (t) := 1 − e −t , i.e. we assume that the arrivals form a Poisson stream with rate λ = 1.</p><formula xml:id="formula_51" coords="13,207.47,769.63,42.96,17.09">b(i, j) i,</formula><p>For a planning horizon of 2, i.e. N = 2, we obtain from (6.3) and (6.4) for the difference of the expected cost between routing to I and routing to II in state s = (k, i, u, j, v) </p><formula xml:id="formula_52" coords="14,91.87,166.17,385.42,67.86">Δ2 (s) = LI Ṽ1 (s) − LII Ṽ1 (s) = [u + b(i, k)] + − [v + b(j, k)] + + β l∈J p l ∞ 0 λe −λt min [[u + b(i, k)] + − t + b(k, l)] + , [v − t + b(j, l)] + − min [u − t + b(i, l)] + , [[v + b(j, k)] + − t + b(k, l)] + dt.</formula><formula xml:id="formula_53" coords="14,166.36,293.03,298.42,37.63">(48 − t)e −t dt + β(1 − p 3 )C 1 ≤ βp 3 (−24)(1 − e −24 ) + β(1 − p 3 )C 1</formula><p>for a constant C 1 not depending on p 3 . For p 3 large enough, we therefore have Δ2 (s) &lt; 0, i.e it is optimal to route to runway I.</p><formula xml:id="formula_54" coords="14,72.00,376.95,339.66,66.80">Now let s := (1, 1, −144, 2, −72) then ū = −144 &lt; −96 = u but Δ2 (s) = βp 3 24 0 (24 − t)e −t dt + β(1 − p 3 )C 2 = βp 3 (23 + e −24 ) + β(1 − p 3 )C 2</formula><p>again for a constant C 2 not depending on p 3 . This time we have Δ2 (s) &gt; 0 for p 3 large enough, i.e. in state s it is optimal to route to II. Hence, for any ordering ≺ on S where u &lt; ū implies (k, i, u, j, v) ≺ (k, i, ū, j, v), Δn (s) need not be s-increasing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">The Monotonicity of s → Δ n (s)</head><p>In this Section we complete the proof of Theorem 4.1. We are using the model of Section 3, i.e. s = (i, u, j, k) and</p><formula xml:id="formula_55" coords="14,160.08,567.94,78.51,11.14">Z n = (J n , T n+1 ).</formula><p>Let us first introduce some notation, that allows to describe the behaviour of the system under fixed sequences of actions and external events. For k ≥ 0 let</p><formula xml:id="formula_56" coords="14,242.50,621.50,111.92,13.21">g k : S × A k × Z k → S</formula><p>be defined by g 0 (s) := s g 1 (s, a, z) := g(s, a, z) as defined in (3.4) g k+1 (s, (a 1 , . . . , a k+1 ), (z 1 , . . . , z k+1 )) = g g k (s, (a 1 , . . . , a k ), (z 1 , . . . , z k )), a k+1 , z k+1 .</p><p>(</p><p>Let a = (a 1 , . . . , a k ) ∈ A k and z = (z 1 , . . . , z k ) ∈ Z k . We denote the components of the state g k (s, a, z) in the following way</p><formula xml:id="formula_58" coords="14,204.54,777.17,321.02,15.17">g k (s, a, z) =: τ k I , h k I , τ k II , h k II (s, a, z) (7.2)</formula><p>g k (s, a, z) is the state after k stages, starting in state s ∈ S, applying actions a ∈ A n and given that the external events z ∈ Z n were observed. Then, e.g. h k I = h k I (s, a, z) denotes the load on runway I and τ k II = τ k II (s, a, z) is the type of the airplane at the tail of queue II at that time. We make extensive use of ideas from <ref type="bibr" coords="15,254.40,157.91,10.91,9.79" target="#b0">[1]</ref>. In <ref type="bibr" coords="15,289.55,157.91,10.91,9.79" target="#b0">[1]</ref>, a more general state transition mechanism is considered. There, the transition function g depends on the action a only via an additional random event y whose distribution q a is controlled by a. Our approach is the special case where q I , q II are distinct one-point measures (cp. Lemma 2.3(i) in <ref type="bibr" coords="15,363.67,198.56,11.28,9.79" target="#b0">[1]</ref>). In <ref type="bibr" coords="15,401.99,198.56,11.52,9.79" target="#b0">[1]</ref> it is shown inductively that s → Δ n (s) is increasing with respect to some partial order on S under a number of conditions. Translated into our context the following conditions are used</p><formula xml:id="formula_59" coords="15,72.00,251.76,453.57,127.41">C.1 s → c(s, I) − c(s, II) is s-increasing C.2 s → g(s, a, z) is s-increasing C.3 g 2 (s, I, II, z, z ) ≥ g 2 (s, II, I, z, z ) for all z, z ∈ Z C.4 s → c(s, I) + βc(g(s, I, z), II) − c(s, II) − βc(g(s, II, z), I) is s-increasing for all z ∈ Z C.5 s → c(g k (g 2 (s, I, II, z, z ), a, z), a) − c(g k (g 2 (s, II, I, z, z ), a, z), a) is s-increasing for all a ∈ A k , z ∈ Z k , a ∈ A, z, z ∈ Z, k ≥ 0.</formula><p>Note that conditions C.3 and C.5 examine the permutation of actions I, II in the first two stages with the rest of the actions and all external events fixed.</p><p>It turns out that these assumptions do not hold in our context. Instead, we need slightly modified conditions C.3 -C.5 which differ from the above only in that we permute the two first actions as well as the two first external events. We therefore use C.1, C.2 and</p><formula xml:id="formula_60" coords="15,72.00,479.14,453.55,84.61">C.3* g 2 (s, I, II, z, z ) ≥ g 2 (s, II, I, z , z) for all z, z ∈ Z C.4* s → c(s, I)+βc(g(s, I, z), II)−c(s, II)−βc(g(s, II, z ), I) is s-increasing for all z, z ∈ Z C.5* s → c(g k (g 2 (s, I, II, z, z ), a, z), a) − c(g k (g 2 (s, II, I, z , z), a, z), a) is s-increasing for all a ∈ A k , z ∈ Z k , a ∈ A, z, z ∈ Z, k ≥ 0.</formula><p>We shall refer to the set { C.1, C.2, C.3*,C.4*,C.5*} of modified conditions as (C*) .We now have to show (a) that the conditions (C*) hold in our model and (b) that the conclusions of <ref type="bibr" coords="15,511.07,593.86,10.91,9.79" target="#b0">[1]</ref>, namely that s → Δ n (s) is s-increasing, hold under (C*).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Verifying the Conditions (C*)</head><p>We start with a Lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Lemma</head><p>With the preceding notation we have for s = (i, u, j, v) ∈ S and for any a <ref type="figure" coords="15,171.21,750.93,15.87,9.71">a, z</ref>) is increasing (with respect to the ordering defined in (4.1)), <ref type="figure" coords="16,173.84,112.41,15.87,9.71">a, z</ref>) is increasing (with respect to the ordering defined in (4.1)), τ k II does not depend on i, u, v.</p><formula xml:id="formula_61" coords="15,99.27,709.77,426.28,53.86">∈ A k , z ∈ Z k , k ≥ 0 a) i → τ k I (s,</formula><formula xml:id="formula_62" coords="15,105.97,748.47,419.58,46.00">τ k I does not depend on u, j, v. b) i, u → h k I (s, a, z) are increasing, h k I does not depend on j, v. c) j → τ k II (s,</formula><formula xml:id="formula_63" coords="16,105.97,141.05,309.47,15.16">d) j, v → h k II (s, a, z) are increasing, h k II does not depend on i, u.</formula><p>Note that u → h k I (s, a, z) and v → h k II (s, a, z) are also convex.</p><p>Proof : a) With s = (i, u, j, v) we have τ 0 I (s, a, z) = i and for k ≥ 1</p><formula xml:id="formula_64" coords="16,116.80,239.76,352.92,25.37">τ k I (s, a, z) = i if a 1 = • • • = a k = II l m if m = max{ν|1 ≤ ν ≤ k, a ν = I} and z m = (l m , t m )</formula><p>.</p><p>Hence i → τ k I is increasing and independent of u, j, v for fixed a, z. To prove b) we proceed by induction on k ≥ 0. Let k = 0. We put</p><formula xml:id="formula_65" coords="16,72.00,319.27,324.07,50.41">H(u, b, t, a) := [u + b] + − t if a = I u − t if a = II Then u, b → H(u, b, t, a</formula><p>) are increasing and convex functions and with z k+1 = (l k+1 , t k+1 ) we see from (</p><formula xml:id="formula_66" coords="16,81.74,373.01,425.86,68.64">h k+1 I (s, a, a k+1 , z, z k+1 ) = H(h k I (s, a, z), b(τ k I (s, a, z), l k+1 ), t k+1 , a k+1 ) = [h k I (s, a, z) + b(τ k I (s, a, z), l k+1 )] + − t k+1 if a k+1 = I h k I (s, a, z) − t k+1 if a k+1 = II. (<label>7.1) and (3.4)</label></formula><p>Assume that a) holds for k. Then u, i → h k i and u, i → b(τ k I (s, a, z), l k+1 ) are increasing mappings that do not depend on j, v. From (7.3) it is then obvious that b) holds for k + 1. c) and d) follow in the same way. Now we can show that the above conditions (C) hold in our model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Lemma</head><formula xml:id="formula_68" coords="16,105.97,568.67,419.60,119.94">a) s → c(s, I) − c(s, II) is s-increasing b) s → g(s, a, z) is s-increasing c) g 2 (s, a, a , z, z ) ≥ g 2 (s, a , a, z , z) for all a, a ∈ A, z, z ∈ Z d) s → c(s, I) + βc(g(s, I, z), II) − c(s, II) − βc(g(s, II, z ), I) is s-increasing for all z, z ∈ Z e) s → c(g k (g 2 (s, I, II, z, z ), a, z), a) − c(g k (g 2 (s, II, I, z , z), a, z), a) is s-increasing for all a ∈ A k , z ∈ Z k , a ∈ A, z, z ∈ Z, k ≥ 0.</formula><p>Proof : a) We have u, i → [u + b(i, j )] + are increasing for all j ∈ J, hence from (4.3) c) To prove c), we look at the components of g 2 (s, I, II, z, z ) and g 2 (s, II, I, z , z). With z = (l, t), z = (l , t ) we have τ 2 I = l and τ 2 II = l in both cases and as [x] + − t ≤ [x − t] + , we obtain</p><formula xml:id="formula_69" coords="16,183.10,748.15,224.31,44.18">s →c(s, I) − c(s, II) = j ∈J p j • [u + b(i, j )] + − [v + b(i, j )] +</formula><formula xml:id="formula_70" coords="17,204.56,181.76,185.62,49.41">h 2 I (s, I, II, z, z ) = [u + b(i, l)] + − t − t ≤ [u − t + b(i, l)] + − t = h 2 I (s, II, I, z , z).</formula><p>In the same way one shows h  </p><formula xml:id="formula_71" coords="17,84.80,360.78,440.75,71.87">= j ∈J p j [u + b(i, j )] + − [v + b(j, j )] + + β[v − t + b(j, j )] + − β[u − t + b(i, j )] + = j ∈J p j [u + b(i, j )] + − β[u − t + b(i, j )] + − [v + b(j, j )] + − β[v − t + b(j, j )] + . (7.4)</formula><p>It is not difficult to see that an expression of the form x → r(x) − β r(x − t) with r increasing and convex and 0 &lt; β ≤ 1 is increasing in x. As u, i → u + b(i, j ) and v, j → v + b(j, j ) are increasing we see from (4.3) that d) holds. e) Fix s = (i, u, j, v) ∈ S and z = (l, t), z = (l , t ) ∈ Z. Define</p><formula xml:id="formula_72" coords="17,125.44,510.14,346.66,31.80">σ 1 := g 2 (s, I, II, z, z ) = (l, [u + b(i, l)] + − t − t , l , [v − t + b(j, l )] + − t ) σ 2 := g 2 (s, II, I, z , z) = (l, [u − t + b(i, l)] + − t, l , [v + b(j, l )] + − t − t).</formula><p>Let us assume that a = I. From Lemma 7.1 b) we see that</p><formula xml:id="formula_73" coords="17,130.06,573.40,337.43,15.17">h k I (σ 1 , a, z) = h k I ((l, [u + b(i, l)] + − t − t , l , [v − t + b(j, l )] + − t ), a, z)</formula><p>is increasing in the first two coordinates of σ 1 and does not depend on the last two, hence it is increasing in i, u and does not depend on j, v. Similarly, h k I (σ 2 , a, z) is increasing in i, u and is independent of j, v. Using Lemma 7.1 a) we therefore have c(g k (g 2 (s, I, II, z, z ), a, z), I) − c(g k (g 2 (s, II, I, z , z), a, z), I)</p><formula xml:id="formula_74" coords="17,117.57,649.35,407.98,96.61">(7.5) = j ∈J p j [h k I (σ 1 , a, z) + b(τ k I (σ 1 , a, z), j )] + − h k I (σ 2 , a, z) + b(τ k I (σ 2 , a, z), j )] + = j ∈J p j [h k I (l, [u + b(i, l)] + − t − t , •, •) + b(τ k I (l, •, •, •), j )] + −[h k I (l, [u − t + b(i, l)] + − t, l , •, •) + b(τ k I (l, •, •, •), j )] +</formula><p>It is not difficult to show that if r : IR → IR is an increasing function and d ∈ IR, t &gt; 0, then</p><formula xml:id="formula_75" coords="17,207.49,778.78,182.56,13.21">x → r([x] + + d − t) − r([x − t] + + d)</formula><p>is increasing. With x = u + b(i, l) we obtain, that (7.5) is increasing in i, u and independent from j, v, hence it is s-increasing. Similarly, for a = II we see that c(g k (g 2 (s, I, II, z, z ), a, z), II) − c(g k (g 2 (s, II, I, z , z), a, z), II)</p><formula xml:id="formula_76" coords="18,110.88,150.45,414.67,96.61">(7.6) = j ∈J p j [h k II (σ 1 , a, z) + b(τ k II (σ 1 , a, z), j )] + − h k II (σ 2 , a, z) + b(τ k II (σ 2 , a, z), j )] + = j ∈J p j [h k II (•, •, l , [v − t + b(j, l )] + − t ) + b(τ k II (•, •, l , •), j )] + −[h k II (•, •, l , [v + b(j, l )] + − t − t) + b(τ k II (•, •, l , •), j )] +</formula><p>is independent of i, u and decreasing in j, v, hence s-increasing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Monotonicity of s → Δ n (s) under Conditions (C)</head><p>We now show that Δ n (s) is s-increasing under our modified conditions. For the sake of completeness, we give a streamlined version of the proofs of <ref type="bibr" coords="18,341.20,354.99,11.52,9.79" target="#b0">[1]</ref> here .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Lemma</head><p>Let (C) hold. For any s ∈ S, n ≥ 0 s → Δ n (s) is s-increasing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof :</head><p>We proceed by induction on n ≥ 0. For n = 0 we have with V 0 ≡ 0 and s = (i, u, j, v)</p><formula xml:id="formula_77" coords="18,179.21,500.55,346.34,11.87">Δ 0 (s) = L I V 0 (s) − L II V 0 (s) = c(s, I) − c(s, II) (7.7)</formula><p>which is s-increasing by condition C.1. Now assume that s → Δ k (s) is s-increasing for all k ≤ n − 1. We shall show that the same holds for Δ n (s). Note that for any a, b ∈ IR we have min{a</p><formula xml:id="formula_78" coords="18,226.31,560.81,299.23,14.12">, b} = b − [b − a] + = a + [b − a] − (7.8)</formula><p>where we denote [a] − := min{0, a}. (7.9)</p><p>We now obtain for any s ∈ S, n ≥ 1</p><formula xml:id="formula_79" coords="18,72.00,645.71,479.73,140.69">Δ n (s) = L I V n (s) − L II V n (s) (7.10) = c(s, I) + β E [V n (X 2 ) | X 1 = s, A 1 = I] − c(s, II) − β E [V n (X 2 ) | X 1 = s, A 1 = II] = c(s, I) + β E [ min a=I,II L a V n−1 (X 2 ) | X 1 = s, A 1 = I] −c(s, II) − β E [ min a=I,II L a V n−1 (X 2 ) | X 1 = s, A 1 = II] = c(s, I) + β E L II V n−1 (X 2 ) + [L I V n−1 (X 2 ) − L II V n−1 (X 2 )] − | X 1 = s, A 1 = I −c(s, II) − β E L I V n−1 (X 2 ) − [L I V n−1 (X 2 ) − L II V n−1 (X 2 )] + | X 1 = s, A 1 = II = c(s, I) + β E [L II V n−1 (X 2 ) | X 1 = s, A 1 = I] + β E [Δ n−1 (X 2 )] − | X 1 = s, A 1 = I −c(s, II) − β E [L I V n−1 (X 2 ) | X 1 = s, A 1 = II] + β E [Δ n−1 (X 2 )] + | X 1 = s, A 1 = II = c(s, I) + β E L II V n−1 (g(s, I, Z 1 )) + β E [Δ n−1 (g(s, I, Z 1 ))] − −c(s, II) − β E L I V n−1 (g(s, II, Z 1 )) + β E [Δ n−1 (g(s, II, Z 1 ))] + .</formula><p>From the induction hypotheses and condition C.2 we now infer that s → Δ n−1 (g(s, a, z)) is s-increasing. As [•] + and [•] − are monotone functions we obtain that</p><formula xml:id="formula_80" coords="19,173.67,204.41,249.69,14.11">s → E [Δ n−1 (g(s, I, Z 1 ))] − + E [Δ n−1 (g(s, II, Z 1 ))] +</formula><p>is s-increasing. For the proof of the Lemma it is therefore sufficient to show that the remainder of (7.10) is s-increasing, i.e.</p><formula xml:id="formula_81" coords="19,107.40,263.97,418.15,76.59">s →c(s, I) + β E L II V n−1 (g(s, I, Z 1 )) − c(s, II) − β E L I V n−1 (g(s, II, Z 1 )) = E c(s, I) + βc(g(s, I, Z 1 ), II) + β 2 V n−1 (g 2 (s, I, II, Z 1 , Z 2 )) − c(s, II) − βc(g(s, II, Z 2 ), I) − β 2 V n−1 (g 2 (s, II, I, Z 2 , Z 1 )) = E ξ(s, Z 1 , Z 2 ) (7.11)</formula><p>where ξ is defined in (7.12) below.</p><p>Note that in the second equation of (7.11) we have exchanged Z 1 , Z 2 , which is possible as they are i.i.d.. This is a minor change from the derivation in <ref type="bibr" coords="19,318.26,382.31,11.52,9.79" target="#b0">[1]</ref> and allows to use conditions C.3* -C.5*.</p><p>As Z 1 , Z 2 are also independent of the rest, the monotonicity of (7.11) follows if s → ξ(s, z 1 , z 2 ) is s-increasing for all z 1 , z 2 ∈ Z which is shown in the next Lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Lemma</head><p>If s → Δ k (s) is s-increasing for all k ≤ n then the following expression is s-increasing for all z, z ∈ Z:</p><formula xml:id="formula_82" coords="19,140.46,501.04,385.09,31.80">ξ(s, z, z ) := c(s, I) + βc(g(s, I, z), II) + β 2 V n (g 2 (s, I, II, z, z )) − c(s, II) − βc(g(s, II, z ), I) − β 2 V n (g 2 (s, II, I, z , z)). (7.12)</formula><p>For the proof of this Lemma we need the following definition let R 0 (s) := 0 and for a</p><formula xml:id="formula_83" coords="19,72.00,554.94,453.55,68.47">= (a 1 , . . . , a k ) ∈ A k and z = (z 1 , . . . , z k ) ∈ Z k let R k (s, a, z) = k−1 m=0 β m c(g m (s, a, z), a m+1 ).</formula><p>Then R k (s, a, z) is the discounted cost over k stages when starting in state s and following a fixed routing policy a, with fixed external events z. Note that g m depends only on part of the sequences a and z.</p><p>Proof : (of Lemma 7.4)</p><p>1. We follow the lines of the proof of Lemma 2.2 in <ref type="bibr" coords="19,320.77,707.45,10.92,9.79" target="#b0">[1]</ref>. For 0 ≤ k ≤ n and z, z ∈ Z let Φ k (s, a, z) := c(s, I) + βc(g(s, I, z), II) + β 2 R k (g 2 (s, I, II, z, z ), a, z)</p><formula xml:id="formula_84" coords="19,172.41,744.41,353.13,50.02">+ β k+2 V n−k (g k (g 2 (s, I, II, z, z ), a, z)) − c(s, II) − βc(g(s, II, z ), I) − β 2 R k (g 2 (s, II, I, z , z), a, z) − β k+2 V n−k (g k (g 2 (s, II, I, z , z), a, z))<label>(7.13)</label></formula><p>where a = (a 1 , . . . , a k ) ∈ A k , z = (z 1 , . . . , z k ) ∈ Z k are arbitrary fixed sequences. The first half of Φ k (•) describes the cost from n + 2 stages starting in state s, when in the first k + 2 stages the fixed policy (I, II, a 1 , . . . , a k ) is used, the external events (z, z , z 1 , . . . , z k ) occur and an optimal policy is used for the remaining n − k stages. The second half of Φ k (•) interchanges the actions I, II and the first two external events z, z .</p><p>2. The main step of the proof is to show that Φ k is s-increasing for all k = 0, . . . , n by downward induction on k = n, . . . , 0. The Lemma then follows as Φ 0 (s) = ξ(s).</p><p>2.1. For k = n, Φ n reduces to the expression (7.21) in Lemma 7.5 below. It is proven there that this expression is s-increasing for any n ≥ 1.</p><p>2.2 Now assume that Φ k+1 (•) is increasing in s for any sequences a ∈ A k+1 and z ∈ Z k+1 . We want to show that the analogous result holds for Φ k (•). Let s ≺ s and put  (7.17)</p><formula xml:id="formula_85" coords="20,109.10,540.13,397.86,38.18">:= V n−k (σ 1 ) − V n−k (σ 2 ) − V n−k (σ 3 ) + V n−k (σ 4 ) ≥ max a ∈A L a V n−k−1 (σ 1 ) − L a V n−k−1 (σ 2 ) − L a V n−k−1 (σ 3 ) + L a V n−k−1 (σ 4 ) . (<label>7</label></formula><p>Here, the last inequality follows as it is assumed in this Lemma that s → Δ l (s) is increasing for all l ≤ n, hence we see from ( where the last step follows from the induction hypotheses. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="10,72.00,263.70,453.63,9.79;10,72.00,277.25,286.38,9.79;10,358.37,274.82,4.23,7.97;10,369.00,277.25,156.55,11.19;10,72.00,290.80,110.28,11.19;10,272.09,301.59,28.49,12.55;10,300.57,301.37,4.23,7.97;10,307.73,303.68,19.82,11.81"><head>Finally, we give</head><label></label><figDesc>a crude error bound on how much the waiting times under policy JLL can deviate from the optimum in the general model. With b * = max i,j∈J b(i, j) as before and b * := min i,j∈J b(i, j) let B := b * − b *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="10,105.96,675.77,86.00,12.67;10,191.96,676.22,4.23,7.97;10,196.70,675.77,223.70,12.67;10,194.20,713.03,5.45,9.79"><head>b)</head><label></label><figDesc>Let b(i, j) := b * , then we have for the JLL policy δ with β &lt; 1 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="13,503.12,202.91,22.43,9.79;13,72.00,239.23,453.60,9.79;13,72.00,252.78,140.99,9.79;13,243.13,275.62,106.86,9.79;13,349.99,272.64,6.58,7.97;13,237.48,292.16,112.70,9.79;13,350.18,289.18,6.58,7.97;13,357.27,292.16,3.03,9.77;13,503.12,283.90,22.43,9.79;13,72.00,319.89,453.65,9.79;13,72.00,333.43,40.01,9.79;13,181.75,344.22,67.49,12.55;13,231.89,355.78,16.49,7.97;13,252.33,344.22,165.13,12.55;13,72.00,370.23,205.79,13.90;13,131.63,399.32,98.53,12.54;13,233.61,416.96,12.89,7.97;13,250.14,402.07,8.02,11.27;13,271.48,391.91,8.47,7.97;13,266.62,413.49,4.23,7.97;13,282.26,402.07,87.24,9.79;13,369.50,399.10,6.58,7.97;13,379.01,401.40,88.18,10.91;13,503.12,402.07,22.43,9.79;13,72.00,435.83,17.58,9.79;13,125.14,449.19,108.49,12.54;13,237.08,466.83,12.89,7.97;13,253.59,451.94,8.02,11.27;13,274.93,441.78,8.47,7.97;13,270.08,463.37,4.23,7.97;13,285.71,451.27,124.40,10.91;13,410.11,448.97,6.58,7.97;13,419.63,451.27,54.05,10.91;13,503.12,451.94,22.43,9.79"><head>(6. 1 )</head><label>1</label><figDesc>As cost function c(s, a) we now take the (deterministic) waiting time of the newly arrived airplane when routed to runway a, i.e. c(s,I) := [u + b(i, k)] + c(s, II) := [v + b(j, k)] + . (6.2)As in the model of Section 3, the optimality equation of the finite horizon dynamic program is given by Ṽn+1 (s) = min a∈A La Ṽn (s) = min{ LI Ṽn (s), LII Ṽn (s)}where for s = (k, i, u, j, v) and w :S → IR + LI w(s) := c(s, I) + β l∈J p l ∞ 0 w l, k, [u + b(i, k)] + − t, j, v − t F (dt)(6.3)and LII w(s) := c(s, II) + β l∈J p l ∞ 0 w l, i, u − t, k, [v + b(j, k)] + − t F (dt). (6.4)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="14,503.12,197.73,22.43,9.79;14,72.00,250.32,453.55,10.91;14,72.24,264.54,226.45,9.79;14,132.26,296.01,65.71,11.14;14,217.72,285.85,8.46,7.97;14,212.87,307.43,4.23,7.97;14,226.68,296.01,32.96,9.79;14,259.63,293.03,9.65,7.97;14,269.78,295.33,24.17,10.91;14,310.91,285.85,8.46,7.97;14,306.06,307.43,8.46,7.97"><head>(6. 5 )</head><label>5</label><figDesc>Now assume that we are in state s = (k, i, u, j, v) := (1, 1, −96, 2, −72). Then we have c(s, I) = c(s, II) = 0 and from (6.5), singling out type 3, Δ 2 (s) = βp 3 24 0 (−24)e −t dt − 48 24</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5" coords="17,72.00,112.39,69.31,9.79;17,72.00,130.17,131.47,9.79"><head></head><label></label><figDesc>is s-increasing. b) follows from Lemma 7.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6" coords="17,72.00,300.93,453.56,9.79;17,72.00,314.48,74.82,9.79;17,81.77,339.46,258.25,10.91"><head></head><label></label><figDesc>d) From the definition of the one-stage cost function in (3.5) we have for s = (i, u, j, v), z = (l, t), z = (l , t ) c(s, I) − c(s, II) + β c(g(s, I, z), II) − c(g(s, II, z ), I)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7" coords="20,138.14,286.06,33.75,11.14;20,172.28,283.08,4.41,7.97;20,177.40,286.06,9.44,9.79;20,187.23,283.08,4.23,7.97;20,191.97,286.06,92.26,9.79;20,306.05,286.06,41.01,11.14;20,347.45,283.08,4.41,7.97;20,352.58,286.06,9.44,9.79;20,362.40,283.08,4.23,7.97;20,367.15,286.06,92.26,9.79;20,138.14,304.15,33.75,11.14;20,172.28,301.17,4.41,7.97;20,177.40,304.15,9.44,9.79;20,187.23,301.17,4.23,7.97;20,191.97,304.15,89.47,9.79;20,303.25,304.15,41.02,11.14;20,344.66,301.17,4.41,7.97;20,349.78,304.15,9.44,9.79;20,359.60,301.17,4.23,7.97;20,364.35,304.15,92.50,9.79;20,72.00,327.67,453.55,11.81;20,72.00,341.22,111.00,11.81;20,221.63,354.77,51.80,11.81;20,288.47,354.77,87.44,11.81;20,497.66,355.45,27.88,9.79;20,72.00,375.47,24.85,9.79;20,92.02,396.23,266.64,11.95;20,173.71,414.60,154.96,9.79;20,329.25,411.62,4.23,7.97;20,333.98,414.60,22.84,11.27;20,357.21,411.62,4.23,7.97;20,361.95,414.60,92.26,9.79;20,184.01,431.62,162.80,10.91;20,347.39,429.32,4.23,7.97;20,352.13,432.30,22.84,11.27;20,375.35,429.32,4.23,7.97;20,380.10,432.30,92.26,9.79;20,184.01,449.30,148.76,10.91;20,333.36,447.01,4.23,7.97;20,338.09,449.98,22.84,11.27;20,361.31,447.01,4.23,7.97;20,366.06,449.98,89.47,9.79;20,184.01,467.68,157.21,9.79;20,341.80,464.69,4.23,7.97;20,346.54,467.68,22.84,11.27;20,369.77,464.69,4.23,7.97;20,374.51,467.68,89.47,9.79;20,194.92,488.27,20.72,9.79;20,216.22,485.30,15.44,7.97;20,238.67,487.59,232.46,11.95;20,497.66,444.12,27.88,9.79;20,72.00,519.37,140.13,9.79;20,99.25,540.81,6.82,9.79"><head>σ 1 :</head><label>1</label><figDesc>= g k (g 2 (s , I, II, z, z ), a, z) σ 2 := g k (g 2 (s , II, I, z , z), a, z)σ 3 := g k (g 2 (s, I, II, z, z ), a, z) σ 4 := g k (g2 (s, II, I, z , z), a, z). ¿From C.2 and C.3* we obtain that σ 1 ≺ σ 2 and σ 3 ≺ σ 4 . Again from C.2 follows σ 3 ≺ σ 1 and σ 4 ≺ σ 2 , hence we have σ 3 ≺ σ 1 , σ 4 and σ 1 , σ 4 ≺ σ 2 . (7.14)Then Φ k (s , a 1 , . . . , a k ,z 1 , . . . , z k ) − Φ k (s, a 1 , . . . , a k , z 1 , . . . , z k ) = c(s , I) + βc(g(s , I, z), II) + β 2 R k (g 2(s , I, II, z, z ), a, z) − c(s , II) − βc(g(s , II, z ), I) − β 2 R k (g 2 (s , II, I, z , z), a, z) − c(s, I) − βc(g(s, I, z), II) − β 2 R k (g 2 (s, I, II, z, z ), a, z) + c(s, II) + βc(g(s, II, z ), I) + β 2 R k (g 2 (s, II, I, z , z), a, z)+ β k+2 V n−k (σ 1 ) − V n−k (σ 2 ) − V n−k (σ 3 ) + V n−k (σ 4 ) (7.15) 2.2.1 We shall now show that Γ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8" coords="20,506.96,553.60,18.59,9.79;20,72.00,589.88,453.55,11.95;20,72.00,603.42,136.01,11.81;20,106.26,626.98,224.27,11.95;20,116.11,643.52,210.60,11.87;20,126.41,660.06,336.99,11.95;20,116.11,676.60,210.60,11.87;20,126.41,693.13,267.61,12.40;20,116.11,710.82,213.63,11.87"><head></head><label></label><figDesc>.16)To simplify the notational we put w(s):= V n−k−1 (s) Assume that a ∈ A is optimal in σ 1 and b ∈ A is optimal in σ 4 . Then Γ ≥ L a w(σ 1 ) − L II w(σ 2 ) − L I w(σ 3 ) + L b w(σ 4 ) = L I w(σ 1 ) − L I w(σ 2 ) − L I w(σ 3 ) + L I w(σ 4 ) − (L I w(σ 1 ) − L a w(σ 1 )) + L I w(σ 2 ) − L II w(σ 2 ) − (L I w(σ 4 ) − L b w(σ 4 )) = L I w(σ 1 ) − L I w(σ 2 ) − L I w(σ 3 ) + L I w(σ 4 ) − 1 [a=II] Δ n−k−1 (σ 1 ) + Δ n−k−1 (σ 2 ) − 1 [b=II] Δ n−k−1 (σ 4 )≥ L I w(σ 1 ) − L I w(σ 2 ) − L I w(σ 3 ) + L I w(σ 4 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9" coords="20,212.79,749.24,46.89,9.79;20,137.27,773.07,323.01,11.95;21,72.00,112.39,128.25,9.79;21,159.18,135.00,237.62,11.87;21,179.33,151.53,259.03,12.40;21,169.03,169.22,230.81,11.87;21,72.00,198.24,267.68,11.14;21,146.23,221.45,41.66,10.91;21,168.17,231.06,19.17,7.97;21,189.72,221.45,190.33,11.81;21,166.38,246.99,270.22,11.95;21,199.12,270.61,252.20,11.95;21,497.66,248.24,27.88,9.79;21,72.00,298.43,453.05,11.27;21,72.00,311.98,43.64,9.79;21,72.00,333.69,33.67,11.27;21,106.06,330.72,4.23,7.97;21,110.79,333.69,138.37,11.27;21,249.54,330.72,4.23,7.97;21,254.29,333.69,113.21,9.79;21,368.07,330.72,4.41,7.97;21,373.19,333.69,14.17,9.77;21,387.75,330.72,4.41,7.97;21,392.87,333.69,9.44,9.79;21,402.70,330.72,4.23,7.97;21,407.44,333.69,120.26,11.27;21,211.17,351.78,34.36,11.27;21,245.91,348.80,4.23,7.97;21,250.65,351.78,113.21,9.79;21,364.44,348.80,4.41,7.97;21,369.56,351.78,50.73,11.27;21,497.66,366.33,27.88,9.79;21,72.00,389.64,148.18,11.14;21,72.00,407.63,279.07,9.79;21,102.37,430.83,110.26,11.95;21,144.53,448.52,154.97,10.91;21,300.08,446.23,4.23,7.97;21,304.80,449.20,33.67,11.27;21,338.86,446.23,4.23,7.97;21,343.59,449.20,92.27,9.79;21,154.84,466.22,162.81,10.91;21,318.22,463.91,4.23,7.97;21,322.95,466.89,33.67,11.27;21,357.00,463.91,4.23,7.97;21,361.74,466.89,92.27,9.79;21,154.84,483.90,148.76,10.91;21,304.18,481.61,4.23,7.97;21,308.91,484.58,33.67,11.27;21,342.96,481.61,4.23,7.97;21,347.71,484.58,89.47,9.79;21,154.84,502.27,157.21,9.79;21,312.62,499.29,4.23,7.97;21,317.36,502.27,33.66,11.27;21,351.41,499.29,4.23,7.97;21,356.15,502.27,89.47,9.79;21,154.84,522.86,17.08,9.79;21,172.49,519.89,15.44,7.97;21,192.07,522.19,275.22,11.95;21,154.84,545.81,268.95,11.95;21,144.53,570.10,207.54,11.27;21,165.74,593.05,186.95,11.95;21,144.53,613.62,16.97,10.91;21,497.66,522.92,27.88,9.79"><head>4 . 2 . 2 . 3</head><label>4223</label><figDesc>7.14) that Δ n−k−1 (σ 2 ) − Δ n−k−1 (σ 1 ) ≥ 0 and Δ n−k−1 (σ 2 ) − Δ n−k−1 (σ 4 ) ≥ 0.In the same way we obtainΓ ≥ L II w(σ 1 ) − L II w(σ 2 ) − L II w(σ 3 ) + L II w(σ 4 ) + 1 [a=I] Δ n−k−1 (σ 1 ) − Δ n−k−1 (σ 3 ) + 1 [b=I] Δ n−k−1 (σ 4 ) ≥ L II w(σ 1 ) − L II w(σ 2 ) − L II w(σ 3 ) + L II w(σ 4 ).2.2.2 Inserting the definition of L a into (7.16) we obtainΓ ≥ max a ∈A c(σ 1 , a ) − c(σ 2 , a ) − c(σ 3 , a ) + c(σ 4 , a ) + β E V n−k−1 (g(σ 1 , a , Z k+1 )) − V n−k−1 (g(σ 2 , a , Z k+1 )) − V n−k−1 (g(σ 3 , a , Z k+1 )) + V n−k−1 (g(σ 4 , a , Z k+1 )) . (7.18)As Φ k depends only on the first k components of a = (a 1 , . . . , a k+1 ) we may choose a = a k+1 to obtainR k+1 (g 2 (s, I, II, z, z ), a, z)) = R k (g 2 (s, I, II, z, z ), a, z)) + β k c(g k (g 2 (s, I, II, z, z ), a, z), a k+1 ) = R k (g 2 (s, I, II, z, z ), a, z)) + β k c(σ 3 , a k+1 ) (7.19)and similarly for σ 1 , σ 2 and σ Returning to (7.15) we obtain from (7.18) and (7.19) Φ k (s , a,z) − Φ k (s, a, z) ≥ c(s , I) + βc(g(s , I, z), II) + β 2 R k+1 (g 2 (s , I, II, z, z ), a, z) − c(s , II) − βc(g(s , II, z ), I) − β 2 R k+1 (g 2 (s , II, I, z , z), a, z) − c(s, I) − βc(g(s, I, z), II) − β 2 R k+1 (g 2 (s, I, II, z, z ), a, z) + c(s, II) + βc(g(s, II, z ), I) + β 2 R k+1 (g 2 (s, II, I, z , z), a, z)+ β k+3 E V n−k−1 (g(σ 1 , a k+1 , Z k+1 )) − V n−k−1 (g(σ 2 , a k+1 , Z k+1 )) − V n−k−1 (g(σ 3 , a k+1 , Z k+1 )) + V n−k−1 (g(σ 4 , a k+1 , Z k+1 )) = E Φ k+1 (s ,a 1 , . . . , a k+1 , z 1 , . . . , z k , Z k+1 ) − Φ k+1 (s, a 1 , . . . , a k+1 , z 1 , . . . , z k , Z k+1 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10" coords="21,75.64,685.32,60.51,9.71;21,99.27,702.99,250.19,10.91;21,349.45,701.23,4.41,7.97;21,354.57,702.99,33.91,10.91;21,389.33,701.23,4.41,7.97;21,398.77,703.66,126.79,9.79;21,99.27,717.22,58.33,9.79;21,160.12,740.65,175.21,9.79;21,335.91,737.67,4.23,7.97;21,340.64,740.65,22.84,11.27;21,363.87,737.67,4.23,7.97;21,368.61,740.65,89.47,9.79;21,181.72,757.66,157.21,10.91;21,339.51,755.36,4.23,7.97;21,344.23,758.34,22.85,11.27;21,367.47,755.36,4.23,7.97;21,372.20,758.34,92.51,9.79;21,497.67,749.43,27.88,9.79"><head>7. 5</head><label>5</label><figDesc>LemmaLet C.4* and C.5* hold. Then for all k ≥ 0, a ∈ A k , z ∈ Z k the following expression is s-increasing:ζ(s) = c(s, I) + βc(g(s, I, z), II) + β 2 R k (g 2 (s, I, II, z, z ), a, z) − c(s, II) − βc(g(s, II, z ), I) − β 2 R k (g 2 (s, II, I, z , z), a, z).(7.21)   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="17,72.00,240.08,453.58,52.86"><head></head><label></label><figDesc>2 II (s, I, II, z, z ) ≥ h 2 II (s, II, I, z z). Hence c), i.e. C.3* follows. Note that h 2 I (s, II, I, z, z ) = [u − t + b(i, l )] + − t which we cannot relate to h 2 I (s, I, II, z, z ) without serious restrictions on the separation times b(i, •). Hence the original condition C.3 as used in [1] need not hold in our model.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement:</head><p>The authors would like to thank the referee of a former version of this paper for useful suggestions concerning the monotonicity with respect to the types.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof :</head><p>We have from the definition of R k ζ(s) = c(s, I) − c(s, II) + β c(g(s, I, z), II) − c(g(s, II, z ), I)</p><p>β m c(g m (g 2 (s, I, II, z, z ), a, z), a m+1 ) − c(g m (g 2 (s, II, I, z , z), a, z), a m+1 ) . <ref type="bibr" coords="22,497.66,194.53,27.88,9.79">(7.22)</ref> The first part of this expression is s-increasing by condition C.4*, the second is a sum of terms which are s-increasing by C.5*.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this paper we have investigated optimal assignment rules in a particular model of aircraft arrivals. We have shown that optimal policies are of switching type only if we restrict the information on which decisions are based to the state of the two runways, i.e. to the workload and the types of aircrafts waiting at the end of the queues.</p><p>Determining the optimal assignment policy explicitely is a most difficult task. Classical approaches as policy iteration or value iteration (see <ref type="bibr" coords="22,327.82,392.07,16.97,9.79" target="#b10">[11]</ref>) are of limited use here due to the complex search space of possible decision rules. Recent approaches to incorporate numerical approximation techniques are presented e.g. in <ref type="bibr" coords="22,299.24,419.17,10.92,9.79" target="#b5">[6]</ref>.</p><p>Our results narrow the space of possible decision rules. If we restrict the search to monotone rules, i.e. to switching levels, we are sure to cover policies that are optimal among those that depend only on the state of the runways.</p><p>The authors of the present paper have some experience with the optimisation of assignment policies using heuristic search methods as genetic algorithms where the expected waiting times are estimated by discrete event simulation. The results of the present paper justify to a certain extent the restriction to monotone policies in this search. Monotone policies or rather the switching levels are easily stored and manipulated on a computer.</p><p>Our future research will focus on two topics. First, we shall investigate models that take into account more than just one arrival. Even in the random environment assumed here, airport controllers usually know about the next few arrivals and may base their decision on that information. Secondly, we shall work on approximation techniques as e.g. in <ref type="bibr" coords="22,442.17,596.70,11.52,9.79" target="#b5">[6]</ref> making use of structural properties as proven in the present paper.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct coords="22,94.43,710.51,431.14,9.79;22,94.43,724.06,431.16,9.79;22,94.43,737.61,194.13,9.79" xml:id="b0">
	<analytic>
		<title level="a" type="main">Optimality of monotonic policies for two-action Markovian decision processes, with applications to control of queues with delayed information</title>
		<author>
			<persName><forename type="first">Eitan</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaler</forename><surname>Stidham</surname></persName>
		</author>
		<idno type="DOI">10.1007/bf01149165</idno>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<title level="j" type="abbrev">Queueing Syst</title>
		<idno type="ISSN">0257-0130</idno>
		<idno type="ISSNe">1572-9443</idno>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="267" to="291" />
			<date type="published" when="1995-09">1995</date>
			<publisher>Springer Science and Business Media LLC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="22,94.43,760.13,431.17,9.79;22,94.43,773.68,431.21,9.79" xml:id="b1">
	<analytic>
		<title level="a" type="main">ROUTING OF AIRPLANES TO TWO RUNWAYS: MONOTONICITY OF OPTIMAL CONTROLS</title>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>Bäuerle</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">O</forename><surname>Engelhardt-Funke</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Kolonko</surname></persName>
		</author>
		<idno type="DOI">10.1017/s0269964804184088</idno>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<title level="j" type="abbrev">Prob. Eng. Inf. Sci.</title>
		<idno type="ISSN">0269-9648</idno>
		<idno type="ISSNe">1469-8951</idno>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="533" to="560" />
			<date type="published" when="2002">2002</date>
			<publisher>Cambridge University Press (CUP)</publisher>
		</imprint>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct coords="23,94.43,112.39,431.13,9.79;23,94.43,125.95,414.60,9.79" xml:id="b2">
	<analytic>
		<title level="a" type="main">Scheduling Aircraft Landings—The Static Case</title>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">E</forename><surname>Beasley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krishnamoorthy</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Y</forename><forename type="middle">M</forename><surname>Sharaiha</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Abramson</surname></persName>
		</author>
		<idno type="DOI">10.1287/trsc.34.2.180.12302</idno>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<title level="j" type="abbrev">Transportation Science</title>
		<idno type="ISSN">0041-1655</idno>
		<idno type="ISSNe">1526-5447</idno>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="180" to="197" />
			<date type="published" when="2000-05">2000</date>
			<publisher>Institute for Operations Research and the Management Sciences (INFORMS)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,148.46,431.20,9.79;23,94.43,162.01,213.09,9.79" xml:id="b3">
	<analytic>
		<title level="a" type="main">Evaluation of Scheduling Methods for Multiple Runways</title>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bolender</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">G</forename><forename type="middle">L</forename><surname>Slater</surname></persName>
		</author>
		<idno type="DOI">10.2514/2.2641</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Aircraft</title>
		<title level="j" type="abbrev">Journal of Aircraft</title>
		<idno type="ISSN">0021-8669</idno>
		<idno type="ISSNe">1533-3868</idno>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="410" to="416" />
			<date type="published" when="2000-05">2000</date>
			<publisher>American Institute of Aeronautics and Astronautics (AIAA)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,184.53,431.13,9.79;23,94.43,198.07,153.43,9.77" xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming: Deterministic and Stochastic Models</title>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Bertsekas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,220.59,431.13,9.79;23,94.43,234.14,133.08,9.77" xml:id="b5">
	<monogr>
		<title level="m" type="main">Neuro-Dynamic Programming Prentice Hall</title>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Bertsekas</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName coords=""><surname>Tsitsiklis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,256.65,431.12,9.79;23,94.43,270.21,431.14,9.79;23,94.43,283.75,46.66,9.79" xml:id="b6">
	<analytic>
		<title level="a" type="main">Analysis of a Customer Assignment Model with No State Information</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Hordijk</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">A</forename><surname>Loeve</surname></persName>
		</author>
		<idno type="DOI">10.1017/s0269964800003508</idno>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<title level="j" type="abbrev">Prob. Eng. Inf. Sci.</title>
		<idno type="ISSN">0269-9648</idno>
		<idno type="ISSNe">1469-8951</idno>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="419" to="429" />
			<date type="published" when="1994-07">1994</date>
			<publisher>Cambridge University Press (CUP)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,306.27,431.12,9.79;23,94.43,319.82,92.96,9.79" xml:id="b7">
	<monogr>
		<title level="m" type="main">Planning and Design of Airports</title>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Horonjeff</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">F</forename><forename type="middle">X</forename><surname>Mckelvey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
	<note>4. ed.</note>
</biblStruct>

<biblStruct coords="23,94.43,342.34,431.21,9.79;23,94.43,355.89,326.63,9.79" xml:id="b8">
	<analytic>
		<title level="a" type="main">On the Pathwise Optimal Bernoulli Routing Policy for Homogeneous Parallel Servers</title>
		<author>
			<persName coords=""><forename type="first">Ger</forename><surname>Koole</surname></persName>
		</author>
		<idno type="DOI">10.1287/moor.21.2.469</idno>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<title level="j" type="abbrev">Mathematics of OR</title>
		<idno type="ISSN">0364-765X</idno>
		<idno type="ISSNe">1526-5471</idno>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="469" to="476" />
			<date type="published" when="1996-05">1996</date>
			<publisher>Institute for Operations Research and the Management Sciences (INFORMS)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,378.40,431.14,9.79;23,94.43,391.95,310.53,9.79" xml:id="b9">
	<analytic>
		<title level="a" type="main">Some explicit formulas for the steady-state behavior of the queue with semi-Markovian service times</title>
		<author>
			<persName coords=""><forename type="first">Marcel</forename><forename type="middle">F</forename><surname>Neuts</surname></persName>
		</author>
		<idno type="DOI">10.1017/s0001867800043160</idno>
	</analytic>
	<monogr>
		<title level="j">Advances in Applied Probability</title>
		<title level="j" type="abbrev">Adv. Appl. Probab.</title>
		<idno type="ISSN">0001-8678</idno>
		<idno type="ISSNe">1475-6064</idno>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">01</biblScope>
			<biblScope unit="page" from="141" to="157" />
			<date type="published" when="1977-03">1977</date>
			<publisher>Cambridge University Press (CUP)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,414.46,431.15,9.79;23,94.43,428.02,377.81,9.79" xml:id="b10">
	<analytic>
		<title level="a" type="main">Markov Decision Processes</title>
		<author>
			<persName coords=""><forename type="first">Martin</forename><forename type="middle">L</forename><surname>Puterman</surname></persName>
		</author>
		<idno type="DOI">10.1002/9780470316887</idno>
	</analytic>
	<monogr>
		<title level="m">Wiley Series in Probability and Mathematical Statistics</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994-04-15">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,450.53,431.23,9.79;23,94.43,464.08,431.15,9.79;23,94.43,477.63,82.63,9.79" xml:id="b11">
	<analytic>
		<title level="a" type="main">Conditions for optimality in dynamic programming and for the limit of n-stage optimal policies to be optimal</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Schäl</surname></persName>
		</author>
		<idno type="DOI">10.1007/bf00532612</idno>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift f�r Wahrscheinlichkeitstheorie und Verwandte Gebiete</title>
		<title level="j" type="abbrev">Z. Wahrscheinlichkeitstheorie verw Gebiete</title>
		<idno type="ISSN">0044-3719</idno>
		<idno type="ISSNe">1432-2064</idno>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="179" to="196" />
			<date type="published" when="1975">1975</date>
			<publisher>Springer Science and Business Media LLC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="23,94.43,500.14,431.17,9.79;23,94.43,513.70,325.42,9.79" xml:id="b12">
	<analytic>
		<title level="a" type="main">A survey of Markov decision models for control of networks of queues</title>
		<author>
			<persName><forename type="first">Shaler</forename><surname>Stidham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Weber</surname></persName>
		</author>
		<idno type="DOI">10.1007/bf01158935</idno>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<title level="j" type="abbrev">Queueing Syst</title>
		<idno type="ISSN">0257-0130</idno>
		<idno type="ISSNe">1572-9443</idno>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="291" to="314" />
			<date type="published" when="1993-03">1993</date>
			<publisher>Springer Science and Business Media LLC</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
